import java.io.File;
import java.io.FileNotFoundException;
import java.util.EmptyStackException;
import java.util.Iterator;
import java.util.Scanner;
import java.util.LinkedList;
import java.util.Stack;



public class HPAir {
	private City [] cities;

	public HPAir(String cityfile, String flightfile)throws FileNotFoundException{


		Scanner cityInput = new Scanner(new File(cityfile));
		Scanner cityInput2 = new Scanner(new File(cityfile));
		Scanner flightInput = new Scanner(new File(flightfile));

		int counter = 0;
		while(cityInput.hasNext()){
			cityInput.nextLine();
			System.out.println(counter++);
		}
		cities = new City[counter];
		for(int i = 0;cityInput2.hasNext();i++){
			cities[i]=new City(cityInput2.nextLine().trim());

		}
		while(flightInput.hasNext()){
			String line = flightInput.nextLine();
			Scanner flightData = new Scanner(line);
			flightData.useDelimiter(",");
			String sourceName = flightData.next().trim();
			City source = findCity(sourceName);
			String destName=flightData.next().trim();
			City dest = findCity(destName);
			int flightNumber = Integer.parseInt(flightData.next().trim());
			int flightCost = Integer.parseInt(flightData.next().trim());
			System.out.println(flightNumber+" "+flightCost);
			Flight flight = new Flight(source,dest,flightNumber,flightCost);
			source.flightList.add(flight);


		}
	}
	public String toString(){
		String s = "Flights\n";
		for(int i = 0;i<cities.length;i++){
			s += cities[i].name+"\n--------------\n";
			for(int j = 0;j<cities[i].flightList.size();j++){
				s += cities[i].flightList.get(j).dest.name;
				if(j<cities[i].flightList.size()-1){
					s+= ", ";
				}
			}
			s+="\n ";
		}
		return s;
	}

	private City findCity(String s){
		if(cities.length==0){
			throw new EmptyStackException ();

		}

		for(int i =0;i<cities.length;i++){
			if(s.equals(cities[i].name)){
				return cities[i];
			}

		}
		return null;
	}
	public void fly(String s, String d){
		System.out.println("Request is to fly from "+s+" to "+d+".\n");
		if(findCity(s)==null){
			System.out.println("We currently do not serve "+s);
			if(findCity(d)==null){
				System.out.print(" or "+d+".");
			}
		}else if(findCity(d)==null){
			System.out.println("We currently do not serve "+d+".");
		}else{
			Stack it = isPath(findCity(s),findCity(d));
			if(!it.isEmpty()){
				System.out.println("Sorry, we do not fly from "+s+" to "+d+".");
			}else{

			}
		}
	}

	private Stack isPath(City s, City d){
		Stack<City> itinerary = new Stack<City>();

		itinerary.add(s);
		s.visited = true;
		//recursive
		if(source == dest){
			//there is a path return something
		}else{
			for(/*each unvisited city on source's flightlist*/ int i = 0;i<s.flightList.size();i++){
				if(isPath(s.flightList.get(i).dest) == true){
					//there is a path return something
				}
			}
			return false;
		}



		//non-recursive
		while(!itinerary.isEmpty() && itinerary.peek != dest){
			City curCity = itinerary.peek;
			if(/*no unvisited cities from curCity remain*/true){
				itinerary.pop();
			}else{
				City c /* = next unvisited city in curCity*/;
				s.push(c);

			}
			//previous code
			/*for(int i = 0;i<itinerary.peek().flightList.size();i++){
if(itinerary.peek().flightList.get(i).dest.equals(d)){
itinerary.add(d);
return itinerary;
}
}
itinerary.pop();
for(int i = 0;i<itinerary.peek().flightList.size();i++){
for(int j = 0;j<itinerary.peek().flightList.get(i).dest.flightList.size();j++){
City name = itinerary.peek().flightList.get(i).dest.flightList.get(j).dest;
if(name.equals(d)){
itinerary.add(d);
return itinerary;
}
}
}*/

		}

		private void reset(){
			//TODO--WRITE RESET
			//reset returns all City.visited booleans to false
			for(int i = 0;i<cities.length;i++){
				cities[i].visited = false;
			}
		}

		private int getCost(Stack<City> it){
			//TODO--WRITE GETCOST
			//getCost returns the total cost of travel from the bottom of a stack to the top
			Iterator<City> itr = it.iterator();
			while(itr.hasNext()){
				City s = itr.next();
				if(itr.hasNext()){
					City d = itr.next();
					
				}
			}

		}

		/*Test class to find shortest path*/

		public class Path{
			public Stack<City> itin;
			public int cost;

			public Path(Stack<City> i){
				itin = i;
				cost = getCost(itin);

			}
		}
		public class City{
			public String name;
			public LinkedList<Flight> flightList;
			public boolean visited;

			public City(String n){
				name=n;
				flightList= new LinkedList<Flight>();
				visited = false;
			}

		}
		public class Flight {
			public City source;
			public City dest;
			public int number;
			public int cost;
			public Flight(City s, City d,int n ,int c){
				source=s;
				dest=d;
				number=n;
				cost=c;
			}
		}

	}

